<thinking>  
この質問は AES の鍵拡張（Key Expansion）において、**最初の鍵（通常128ビット = 16バイト）から、Word（4バイト単位の配列）をどのように生成していくのか**という点に焦点がある。


ポイントは：
	•	AES-128では16バイトの鍵を4バイトずつ区切って、W[0]〜W[3] までの初期ワードをまず作成する（これは「元鍵」）
	•	残りのワード W[4]〜W[43] は、W[i] = W[i-4] ⊕ g(W[i-1]) または W[i-1] というルールで導き出す

つまり、鍵拡張におけるワードは、鍵の4バイトごとの切り出し ＋ g関数 + XOR によって、連鎖的に生成される

これを段階的に解説する


<steps>


Step 1: AES-128では鍵は16バイト（128ビット）

unsigned char key[16] = {
  0x2b, 0x7e, 0x15, 0x16,
  0x28, 0xae, 0xd2, 0xa6,
  0xab, 0xf7, 0x15, 0x88,
  0x09, 0xcf, 0x4f, 0x3c
};

残り 19

⸻

Step 2: 鍵はまず 4つのワード（W[0]〜W[3]）に分割される

W[0] = {0x2b, 0x7e, 0x15, 0x16}
W[1] = {0x28, 0xae, 0xd2, 0xa6}
W[2] = {0xab, 0xf7, 0x15, 0x88}
W[3] = {0x09, 0xcf, 0x4f, 0x3c}

→ これがラウンド鍵生成の スタートポイント

残り 18

⸻

Step 3: 残りのワード W[4]〜W[43] を生成する

AES-128では、ラウンドごとに4ワード（16バイト）の鍵が必要 → 44ワード = 11ラウンド鍵

for (i = 4; i < 44; i++) {
  if (i % 4 == 0) {
    W[i] = W[i-4] ⊕ g(W[i-1])
  } else {
    W[i] = W[i-4] ⊕ W[i-1]
  }
}

残り 17

⸻

Step 4: g関数とは？

g(W) は以下の3ステップ：
	1.	RotWord → 左ローテート（4バイトのうち左に1バイト回す）
	2.	SubWord → 各バイトをS-boxで置換
	3.	XOR 最初のバイトに Rcon[i / Nk] を加える

→ W[4] = W[0] ⊕ g(W[3])

残り 16

⸻

Step 5: 具体例：W[4] の生成

W[3] = {0x09, 0xcf, 0x4f, 0x3c}
RotWord(W[3]) = {0xcf, 0x4f, 0x3c, 0x09}
SubWord()     = {S(cf), S(4f), S(3c), S(09)}
XOR with Rcon = W_g = {S(cf)^0x01, S(4f), S(3c), S(09)}

W[4] = W[0] ⊕ W_g

残り 15

⸻

Step 6: W[5] = W[1] ⊕ W[4]

以降は i % 4 != 0 なので、単純なXOR：

W[5] = W[1] ⊕ W[4]
W[6] = W[2] ⊕ W[5]
W[7] = W[3] ⊕ W[6]

残り 14

⸻

Step 7: 次のラウンド（W[8]〜W[11]）

W[8]  = W[4]  ⊕ g(W[7])
W[9]  = W[5]  ⊕ W[8]
W[10] = W[6]  ⊕ W[9]
W[11] = W[7]  ⊕ W[10]

→ これを繰り返して W[43] まで作る

残り 13

⸻

Step 8: ラウンドキーの構成
	•	各ラウンドキー = 4つのワード（W[i], W[i+1], W[i+2], W[i+3]）
	•	AES-128ではラウンド0〜10（全11ラウンド）

残り 12

⸻

Step 9: C言語でのワードの表現

typedef unsigned char Word[4];  // 4バイトのワード
Word expandedKeys[44];          // 44ワード分の拡張鍵

残り 11

</steps>


<answer>  
🔐 **AESのKey Expansionにおける Word（ワード）の導出方法：**


🔹 Step 1: 初期鍵から最初のワードを作る

鍵（16バイト）を4バイトずつに分けて：

W[0] = {0x2b, 0x7e, 0x15, 0x16}
W[1] = {0x28, 0xae, 0xd2, 0xa6}
W[2] = {0xab, 0xf7, 0x15, 0x88}
W[3] = {0x09, 0xcf, 0x4f, 0x3c}


⸻

🔹 Step 2: 残りは以下のルールで順に導出

for i = 4 to 43:
  if (i % 4 == 0)
    W[i] = W[i-4] ⊕ g(W[i-1])
  else
    W[i] = W[i-4] ⊕ W[i-1]

ここで g() は：
	1.	1バイト左回転 (RotWord)
	2.	S-box変換 (SubWord)
	3.	Rcon定数とXOR

⸻

🔹 Step 3: すべてのW[i]が出揃うとラウンド鍵が完成
	•	AES-128では 44ワード（=11ラウンド×4ワード）
	•	ラウンド鍵 = W[4i] 〜 W[4i+3]

</answer>


<reflection>  
AESの鍵拡張の流れにおける「ワード」の生成過程を、元鍵から順にステップで辿ることで理解が深まりやすくなった。C実装を想定して型定義にも触れ、演算の順序と意味も明確にできた。g関数の中身との連携も意識して説明できた。


</reflection>


0.99